# Memory barrier
https://fgiesen.wordpress.com/2014/07/07/cache-coherency/

使用强一点的内存模型的体系结构则会在内部做很多记录工作。
比如，x86会跟踪所有在等待中的内存操作，这些操作都还没有完全完成（称为“退休（retired）”）。
它会把它们的信息保存在芯片内部的MOB（“memory ordering buffer”，内存排序缓冲）。x86作为部分支持乱序执行的体系结构，
在出问题的时候能把尚未“退休”的指令撤销掉——比如发生页错误（page fault），或者分支预测失败（branch mispredict）的时候。我已经在我以前的文章“好奇地说”中提到过一些细节，以及和内存子系统的一些交互。主旨是x86处理器会主动地监控外部事件（比如缓存失效），有些已经执行完的操作会因为这些事件而被撤销，但不算“退休”。这就是说，x86知道自己的内存模型应该是什么样子的，当发生了一件和这个模型冲突的事，处理器会回退到上一个与内存模型兼容的状态。这就是我在以前另一篇文章中提到的“清除内存排序机（memory ordering machine clear）”。最后的结果是，x86处理器为内存操作提供了很强的一致性保证——虽然没有达到完美的顺序一致性。

# CPU pipeline

关于CPU的流水线(pipeline)并发性简单说说，
Intel Pentium处理器有两条流水线U和V，
每条流水线可各自独立地读写缓存，
所以可以在一个时钟周期内同时执行两条指令。
但这两条流水线不是对等的，
U流水线可以处理所有指令集，V流水线只能处理简单指令。

```
int steps = 256 * 1024 * 1024;
int[] a = new int[2];
 
// Loop 1
for (int i=0; i<steps; i++) { a[0]++; a[0]++; }
 
// Loop 2
for (int i=0; i<steps; i++) { a[0]++; a[1]++; }
```

第一个循环里，后面的 a[0]++ 依赖前面的 a[0]++，只能顺序执行
而第二个循环2个++操作可以并发执行，第二个循环要比第一个循环快一倍。