# go stack
Stack 在 Linux 上默认值是 8192KB
```
ulimit -s
8192
```
```c
#include <sys/resource.h>
#include <stdio.h>

int main() {
    struct rlimit rlim;
    getrlimit64(RLIMIT_STACK, &rlim);
    // cur for soft, max for hard
    printf("rlim_cur => %llx, :rlim_max => %#llx\n",
           rlim.rlim_cur, rlim.rlim_max);
    return 0;
}

--- out
rlim_cur => 800000, :rlim_max => 0xffffffffffffffff
```

stack grow
```
                         +--------------+ high
                         |              |
                    +    |              |
                    |    +--------------+
                    |    |              |
                    |    |   arg(N-1)   |  starts from 7'th argument for x86_64
                    |    |              |
                    |    +--------------+
                    |    |              |
                    |    |     argN     |
                    |    |              |
                    |    +--------------+
                    |    |              |
                    |    |Return address|  %rbp + 8
Stack grows down    |    |              |
                    |    +--------------+
                    |    |              |
                    |    |     %rbp     |  Frame base pointer
                    |    |              |
                    |    +--------------+
                    |    |              |
                    |    |  local var1  |  %rbp - 8
                    |    |              |
                    |    +--------------+
                    |    |              |
                    |    | local ^ar 2  |
                    v    +--------------+
                         |              |
                         |              |
                         +--------------+ low
                         
# from https://0xax.github.io/
```

## go stack layout
runtime/runtime2.go
```go
type stack struct {
  	lo uintptr
  	hi uintptr
}
// g 代表 GMP 模型的 G
type g struct {
  	// Stack parameters.
  	// stack describes the actual stack memory: [stack.lo, stack.hi).
  	// stackguard0 is the stack pointer compared in the Go stack growth prologue.
  	// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.
  	// stackguard1 is the stack pointer compared in the C stack growth prologue.
  	// It is stack.lo+StackGuard on g0 and gsignal stacks.
  	// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).
  	stack       stack   // offset known to runtime/cgo
  	stackguard0 uintptr // offset known to liblink
  	stackguard1 uintptr // offset known to liblink
```
stackguard1 = stack.lo + StackGuard

StackGuard Size
```go
// runtime/stack.go
const (
    // 操作系统相关
    // on Linux is 0
    _StackSystem = sys.GoosWindows*512*sys.PtrSize + sys.GoosPlan9*512 + sys.GoosDarwin*sys.GoarchArm*1024

    // The minimum size of stack used by Go code
  	_StackMin = 2048
  	
    // After a stack split check the SP is allowed to be this
    // many bytes below the stack guard. This saves an instruction
    // in the checking sequence for tiny frames.
    _StackSmall = 128

    // The stack guard is a pointer this many bytes above the
  	// bottom of the stack.
  	_StackGuard = 880*sys.StackGuardMultiplier + _StackSystem
  	// gcflags 没有指定 -N  StackGuardMultiplier = 1
  	// StackGuard = 880*1 + 0 = 880
  
)
```
StackGuardMultiplier 是动态生成的, cmd/dist/buildruntime.go
```go
// 代码生成到 zversion.go
func mkzversion(dir, file string) {
	out := fmt.Sprintf(
		"// auto generated by go tool dist\n"+
			"\n"+
			"package sys\n"+
			"\n"+
			"const DefaultGoroot = `%s`\n"+
			"const TheVersion = `%s`\n"+
			"const Goexperiment = `%s`\n"+
			"const StackGuardMultiplier = %d\n\n", goroot_final, findgoversion(), os.Getenv("GOEXPERIMENT"), stackGuardMultiplier())

	writefile(out, file, writeSkipSame)
}
// const StackGuardMultiplier = 1 if gcflags not set -N
func stackGuardMultiplier() int {
	for _, s := range strings.Split(os.Getenv("GO_GCFLAGS"), " ") {
		if s == "-N" {
			return 2
		}
	}
	return 1
}
```
可以看到 stackguard1 = stack.lo + StackGuard(880)

stack layout
```
 +--------------+ stack.hi
 |              |
 |              |  SP
 |              |  |
 |              |  |
 |              |  v
 |              |
 +--------------+ stackguard0 = stak.lo + 0x370(880)
 |              |
 |  StackGuard  |
 |              |
 +--------------+ stak.lo
```

# stack 分配

每次运行 goroutine 总是申请/施放 stack 内存，开销很大，runtime 采用了stack cache pool来缓存一定数量的 stack memory



主协程 g0 初始化 stack 是 8192



子协程堆栈初始化， 创建一个goroutine 先分配2KB stack，用来执行函数调用

链接器在每个函数调用的开始部分会增加一段代码，用于检测是否需要进行栈扩容
```go
// runtime/proc.go

// Create a new g running fn with narg bytes of arguments starting
// at argp and returning nret bytes of results.  callerpc is the
// address of the go statement that created this. The new g is put
// on the queue of g's waiting to run.
func newproc1(fn *funcval, argp *uint8, narg int32, nret int32, callerpc uintptr) *g {
	_g_ := getg()

	_p_ := _g_.m.p.ptr()
	newg := gfget(_p_)
	if newg == nil {
	    // m stack 2KB
		newg = malg(_StackMin)
		casgstatus(newg, _Gidle, _Gdead)
		allgadd(newg) // publishes with a g->status of Gdead so GC scanner doesn't look at uninitialized stack.
	}
	
	// 计算 SP 地址
	totalSize := 4*sys.RegSize + uintptr(siz) + sys.MinFrameSize // extra space in case of reads slightly beyond frame
	totalSize += -totalSize & (sys.SpAlign - 1)                  // align to spAlign
	sp := newg.stack.hi - totalSize
	spArg := sp
	
	// 设置新建协程的栈顶sp
    newg.sched.sp = sp
    ...
    
// Allocate a new g, with a stack big enough for stacksize bytes.
func malg(stacksize int32) *g {
	newg := new(g)
	if stacksize >= 0 {
		stacksize = round2(_StackSystem + stacksize)
		// 分配地址空间
		systemstack(func() {
			newg.stack = stackalloc(uint32(stacksize))
		})
		// 设置 stackguard0 地址
		newg.stackguard0 = newg.stack.lo + _StackGuard
		newg.stackguard1 = ^uintptr(0)
	}
	return newg
}
```
在分配 stack 空间时，会判断大小
```go
func stackalloc(n uint32) stack {
    // Small stacks are allocated with a fixed-size free-list allocator.
	// If we need a stack of a bigger size, we fall back on allocating
	// a dedicated span.
	
	// in malloc.go
	// _StackCacheSize = 32 * 1024  = 32KB
	//   OS               | FixedStack | NumStackOrders
	//   -----------------+------------+---------------
	//   linux/darwin/bsd | 2KB        | 4
	// _FixedStack << 4 = 32768 = 32KB
	
	
	// 如果待分配 stack 小于 32KB
	if stackCache != 0 && n < _FixedStack<<_NumStackOrders && n < _StackCacheSize {
	    if c == nil || thisg.m.preemptoff != "" || thisg.m.helpgc != 0 {
	        // 从 stackpool 分配
	        x = stackpoolalloc(order)
	    } else {
            // 从 stackcache 
            x = c.stackcache[order].list
            // 提取失败
            if x.ptr() == nil {
                stackcacherefill(c, order)
                x = c.stackcache[order].list
            }
	    }
	    
       
	
```


m 内存分配 
```go
// runtime/proc.go

// Allocate a new m unassociated with any thread.
func allocm(_p_ *p, fn func()) *m {

    if iscgo || GOOS == "solaris" || GOOS == "windows" || GOOS == "plan9" {
		mp.g0 = malg(-1)
	} else {
	    // on Linux 8192
		mp.g0 = malg(8192 * sys.StackGuardMultiplier)
	}
	
```
可以看到分配的空间是 8192 字节 4KB


stackpool 是个mSpanList数组  
```go
// runtime/stack.go
var stackpool [_NumStackOrders]mSpanList

func stackinit() {
	if _StackCacheSize&_PageMask != 0 {
		throw("cache size must be a multiple of page size")
	}
	for i := range stackpool {
		stackpool[i].init()
	}
	for i := range stackLarge.free {
		stackLarge.free[i].init()
	}
}
```