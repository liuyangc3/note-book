## Linux time system
### 能产生时钟信号的设备
* RTC `Real-Time Clock`
RTC 是主板上的一个 CMOS 芯片,独立于CPU集成在主板芯片上,是电池供电的，所以掉电后时间不丢失。

Linux 内核把RTC用作“离线”的时间与日期维护器。当Linux内核启动时，它从RTC中读取时间与日期，作为基准值。在运行期间内核完全抛开RTC，以软件的形式维护系统的当前时间与日期，并在需要时将时间回写RTC芯片。

https://www.kernel.org/doc/Documentation/rtc.txt

RTC 提供了 IRQ 中断并且可以定时，所以 RTC 还可以作为内核睡眠时唤醒内核的闹钟，应用程序可以用RTC提供的周期中断做一些周期的任务。

* TSC `Time Stamp Counter` 时间戳计数器

从 Pentium 起，提供一个寄存器 TSC，用来累计每一次外部振荡器产生的时钟信号，x86 处理器有一条 CLK 输入引线,接收外部振荡器的信号,每次收到信号就加1。

可以提供x86提供的指令 rdtsc 访问这个寄存器。因此 TSC 也可以作为时钟设备。TSC 提供了比 RTC 更高精度的时间，即纳秒级的时间精度。

Linux使用这个计数器用来计算CPU频率,例如2.4GHZ的CPU每秒震荡2.4*10^6,内核会在 5ms 内检查计数器的增量来进行计算.

* PIT `Programmable interval Timer`可编程间隔定时器,这个设备发出一个特殊中断`timer interrupt`时钟中断.

在Linux中PIT以内核确定的一个频率向IRQ0发出时钟中断,这个频率根据CPU架构和内核版本的不同而不同,在x86,2.6内核的Linux中,频率是1000HZ,即1ms一次中断.可以用以下命令查看
```
cat /boot/config-2.6.x|grep CONFIG_HZ
```
* HPIT  `High Precision Event Time`
PIT 精度低，HPIT 精度高

* APIC Timer - Advanced Programmable Interrupt Controller Timer
APIC定时器，APIC 主要用于多处理器系统，用来支持复杂的中断控制以及多 CPU 之间的中断传递。APIC Timer 就集成在 APIC 芯片中，用来提供高精度的定时中断，中断频率至少可以达到总线频率。

为了发挥 SMP 体系的并行性, Intel引入了 I/O APIC `I/O Advanced Programmable Interrupt Controller` IO高级可编程中断控制器,
全局有一个 I/O APIC，每个 CPU 上有自己的本地 APIC,所有本地 APIC 通过系统总线连接到 I/O APIC.

这样每个 CPU 上都有一个 APIC Timer，频率是基于总线的时钟信号，而 PIT 则是由系统中所有的 CPU 共享的。Per CPU 的 Timer 简化了系统设计，目前 APIC Timer 已经集成到了所有 Intel x86 处理器中。


* ACPI PMT
`Advanced Configuration and Power Interface`高级配置与电源接口`Power Management Timer`高级管理定时器,所有支持ACPI的主板都有这个定时器,一般是3.85MHz的固定频率

## Linux kernel 计时器
### 低精度定时器
内核里有一个32位有符号值jiffies,用来记录启动以来时钟中断次数,x64里是64位的低32位,每次时钟中断jiffies就加1

### 时间轮
从 Linux2.4 开始，内核通过一种被称为时间轮的算法来保证 add_timer()、del_timer() 以及 expire 处理操作的时间复杂度都为 O(1).
一个数组bukket,每个元素bukket[i]代表i秒后,是一个链表,链表内是定时器.

## 高精度定时器
高精度定时器由红黑树管理，而非时间轮



## function


```c
#include <time.h>
#include <stdio.h>
#include <stdlib.h>

void time_ctime(){
  time_t t;
  time(&t);  // 1970/1/1 00:00:00 到现在的秒数

  printf("Time is: %d\n", t);
  printf("Ctime is: %s\n", ctime(&t));
}

void time_localtime() {
  time_t t;
  struct tm * time_struct;
  time(&t);

  char buf [100];
  time_struct = localtime(&t);
  strftime(buf,100,"It is now: %I:%M %p\n",time_struct);
  puts(buf);
  
}

void get_time_of_day() {
  // 高精度
  struct timeval tv; //stdlib.h
  gettimeofday(&tv,NULL); // 1970/1/1 00:00:00 到现在的微秒数
  printf("High Time: %d.%d\n",tv.tv_sec,tv.tv_usec); 

}

#define rdtsc(low,high) __asm__ \
 __volatile__("rdtsc" : "=a" (low), "=d" (high))

void no_system_call() {
  // 高精度,避免gettimeofday系统调用
  // 读取 x86 TSC 设备
  unsigned low, high;
  rdtsc(low,high)
  unsigned long long cycles; // cpu 周期
  cycles = high;
  cycles = (cycles << 32) | low; //将 low 和 high 合成一个 64 位值
  
  float hz = 2127.985 // cup hz, get it in /proc/cpuinfo
}
```

# 参考
http://www.ibm.com/developerworks/cn/linux/1308_liuming_linuxtime4/

http://www.ibm.com/developerworks/cn/linux/1307_liuming_linuxtime1/
