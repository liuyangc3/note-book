CFS 的设计目标
 * O(1)
 * SMP 支持，每个处理器有独立的lock和runqueue
 * 公平性，每个task都尽量得到CPU时间片，不会出现饿死的情况

调度器runqueue的结构体`struct rq`定义在`kernel/sched.c`文件中。

>为什么不在`linux/sched/h`里定义,因为这是调度器相关的数据，并不希望曝露出去，如果放在头文件里，其他的代码也可以访问runqueue了。

我们看一下这个结构体：
```c
// kernel/sched.c  2.6.32

/*
 * This is the main, per-CPU runqueue data structure.
 *
 * Locking rule: those places that want to lock multiple runqueues
 * (such as the load balancing or the thread migration code), lock
 * acquire operations must be ordered by ascending &runqueue.
 */
struct rq {
	/* runqueue lock: */
	spinlock_t lock;

	/*
	 * nr_running and cpu_load should be in the same cacheline because
	 * remote CPUs use both these fields when doing load calculation.
	 */
	unsigned long nr_running;  /* number of runnable tasks */
	#define CPU_LOAD_IDX_MAX 5
	unsigned long cpu_load[CPU_LOAD_IDX_MAX];

	/* capture load from *all* tasks on this cpu: */
	struct load_weight load;
	unsigned long nr_load_updates;
	u64 nr_switches;   /* context switch count */

	struct cfs_rq cfs;
	struct rt_rq rt;
...
```

通过处理器或者task，一组宏用来获取相关的 runqueue 
 * 宏 cpu_rq(processor) 返回 某个处理器上的 runqueue 的指针;
 * 宏 this_rq() 返回当前处理器的 runqueue 的指针;
 * task_rq(task) 返回 给定 task 所处的 runqueue 指针.


