source: http://mysqlmusings.blogspot.com/2012/06/binary-log-group-commit-in-mysql-56.html

translate: web

binary log group commit 
-----------------------

MySQL 5.6 包含新特性binary log group commit  BGC。
这个功能主要是为了提升MySQL二进制日志的性能. 简单来说，通过按组写二进制日志方式代替之前一个接一个的写入方式 。
在介绍它的细节前，我先简单介绍一下事务是如何写入二进制日志的。
在此前我们先看看如何开启BGC。

什么都不用做。

是的，开启BGC不用任何操作，它对任何存储引擎都是有效的，不用去扩展handlerton 接口来实现BGC。然而InnoDB的一些优化利用了BGC。

binlog_order_commits={0|1}

修改和设置这个全局变量无需停止mysql服务器。

如果是关闭的(0),事务有可能是并行提交的，在一些情况下可能会带来性能的提升。为了测试我们开启了它，虽然吞吐量上并没有明显的提升，
但我们仍决定开启它，说不定在哪些特定情况下它可以发挥作用。

binlog_max_flush_queue_time=microseconds

(表示在处理BGC之前，保持从flush队列读取事务用的时间)

这不是一个操作超时时间，具体是从flush队列取出二进制日志的频率和将日志写入磁盘需要多久。


大量事务....
--------
服务器执行事务时，它会通过基于每个连接的事务缓存，收集事务改变。如果使用基于 statement 的复制，
statements 将被写入事务缓存，如果复制是基于行(row)的，实际被改变的行被写入事务缓存。一旦事务提交了，
事务缓存被当作一个单一的block被写入二进制日志。这允许每个会话按自己照顺序独立的执行，仅当事务数据写入binlog时，需在binlog上加一把锁。
因为每个会话的事务是隔离的，仅在提交时序列化事务已经足够了。（当然这只是理想情况，根据隔离级别的设置，一个事务可以看到其他事务的改动，
所以你不会这么做除非你准确知道你在做什么，对吧？）

![](image/2PC.png)

为了保证存储引擎和binlog是同步的，服务器实现了2段式提交协议(2PC)，如上图所示，有一次调用write() 和一次调用 fsync()。

两段式提交的意义在于，保证事务同时在引擎和binlog中，或者都不在，甚至服务器崩溃。2PC要求一旦事务在引擎中准备好了，
事务要么全部提交要么全部回滚，即便服务器崩溃和恢复。

事务提交前必须要落盘，这就是为什么调用 fsync()，它确保了文件写入到磁盘上。

声名狼藉的prepare_commit_mutex
-------------------------
当服务器恢复时，通过访问binlog决定哪些去提交，哪些去回滚，但是如果没有binlog呢？

一般情况下，一次恢复可以回滚所有的准备的事务，回滚准备但没提交的事务是安全的

